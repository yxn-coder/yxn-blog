## 1、附上题目链接

 - **滑动窗口 思想（一般用于求最小值）：**

	[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

	[713. 乘积小于K的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/)

	[862. 和至少为 K 的最短子数组](https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/)

- **前缀和 思想（一般用于求和）：**

	[560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

	[523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

- **动态规划 思想（一般用于求最大值）：**

	[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

	[剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

	[152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

## 2、代码关键点详解

### 2.1 关键点：滑动窗口 思想

#### 2.1.1 长度最小的子数组

[209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        // 滑动窗口
        int left = 0, right = 0;
        int minLen = Integer.MAX_VALUE;
        int sum = 0;
        while (right < nums.length) {
            sum += nums[right];
            right++;
            while(left < nums.length && sum >= s) {
                minLen = Math.min(minLen, right - left); // 更新
                sum -= nums[left];
                left++;
            }
        }

        return minLen == Integer.MAX_VALUE ? 0 : minLen;
```
**关键点1：滑动窗口**
- 注意：涉及到**连续子数组**的题，要**优先考虑滑动窗口思想**。由于**数组中的元素都为正数**，所以**可以直接用滑动窗口**。**若数组中含有负数，需要先计算前缀和，在采用滑动窗口思想**。

**关键点2：不存在符合条件的子数组，返回 0**
- **` return minLen == Integer.MAX_VALUE ? 0 : minLen;`**

#### 2.1.2 乘积小于K的子数组
[713. 乘积小于K的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/)

```java
class Solution {
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        if (k == 0) return 0;
        int res = 0;
        int left = 0, right = 0;
        int mul = 1; // 乘积
        while (right < nums.length) {
            mul *= nums[right];
            right++;

            while (left < right && mul >= k) {
                mul = mul / nums[left];
                left++;
            }
            res += (right - left); // 更新结果值
        }
        return res;
    }
}
```
**关键点1：算法流程**
1. 我们使用一重循环枚举 right，同时设置 left 的初始值为 0。
2. 在循环的每一步中，表示 right 向右移动了一位，将乘积乘以 nums[right]。
3. 此时我们需要向右移动 left，直到满足乘积小于 k 的条件。
4. 在每次移动时，需要将乘积除以 nums[left]。
5. 当 left 移动完成后，对于当前的 right，就包含了 right−left+1 个乘积小于 k 的连续子数组。

#### 2.1.3 和至少为 K 的最短子数组
[862. 和至少为 K 的最短子数组](https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/)

```java
class Solution {
    public int shortestSubarray(int[] A, int K) {
        /*
            滑动窗口:
                1.当前元素小于队尾，队尾弹出
                2.当前元素-队头>=K，队头弹出
        */
        if (A.length == 0) return -1;
        int[] preSumArray = new int[A.length + 1];
        for (int i = 1; i <= A.length; i++) {
            preSumArray[i] = preSumArray[i - 1] + A[i - 1];
        } 
        LinkedList<Integer> ll = new LinkedList<>();
        int minLen = Integer.MAX_VALUE;
        for (int i = 0; i < preSumArray.length; i++) {
            // 1.当前元素小于等于队尾，队尾弹出
            while (!ll.isEmpty() && preSumArray[i] <= preSumArray[ll.peekLast()]) {
                ll.pollLast();
            }
            // 2.当前元素-队头>=K，队头弹出
            while (!ll.isEmpty() && preSumArray[i] - preSumArray[ll.peek()] >= K) {
                minLen = Math.min(minLen, i - ll.poll());
            }
            ll.add(i);
        }

        return minLen == Integer.MAX_VALUE ? -1 : minLen;
    }
}
```
**关键点1：滑动窗口**
- 对于这种存在正负数元素的数组，当我们想要用滑动窗口算法时，需要先计算数组的前缀和

**关键点2：当前元素小于等于队尾，队尾弹出**
- **队列中存储的是一个单调递增的序列**，这样才能**保证 当前元素 - 队头 >= K 可能成立**

-----------------------------------------------------------------------------------------------
### 2.2 关键点：前缀和 思想

#### 2.2.1 和为K的子数组
[560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)
```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        /* 前缀和 + 双层 for 循环 */
        // int len = nums.length;
        // int[] preSum = new int[len + 1];
        // preSum[0] = 0;
        // for (int i = 1; i <= len; i++) {
        //     preSum[i] = preSum[i - 1] + nums[i - 1]; // 前缀和
        // }

        // int count = 0;
        // for (int i = 0; i <= len; i++) {  // 双层 for 循环
        //     for (int j = i + 1; j <= len; j++) {
        //         if (preSum[j] - preSum[i] == k) {
        //             count++;
        //         }
        //     }
        // }
        // return count;


        /* 前缀和 + hashMap (推荐) */
        int count = 0;
        int preSum = 0;
        // key：前缀和，value：key 对应的前缀和的个数
        Map<Integer,Integer> preSumMap = new HashMap<>();
        // 对于下标为 0 的元素，前缀和为 0，个数为 1
        preSumMap.put(0, 1);

        for(int num : nums){
            preSum += num;
            // 先获得前缀和为 preSum - k 的个数，加到计数
            if (preSumMap.containsKey(preSum - k)){
                count +=  preSumMap.get(preSum - k);
            }

            // 然后维护 preSumFreq 的定义
            preSumMap.put(preSum, preSumMap.getOrDefault(preSum, 0) + 1);
        }
        return count; 
    }
}
```
**关键点1：前缀和**
- **`连续子数组、存在正负数`**，出现这种关键词可以优先考虑 `前缀和`思想。

#### 2.2.2 连续的子数组和
[523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)
```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
    //     /* 前缀和 + 双层 for 循环 */
    //     if (nums.length < 2) return false; // 长度不符合最小要求

    //     int[] preSum = new int[nums.length + 1];
    //     for (int i = 0; i < nums.length; i++) {
    //         preSum[i + 1] = preSum[i] + nums[i];

    //         //当nums中有连续0, 无论k为何值都是正确的 ！！！！
    //         if(i + 1 < nums.length && nums[i] == 0 && nums[i+1] == 0) { 
    //             return true;
    //         } 
    //     }

    //     // k = 0 并且不存在连续的子数组和为 0 的情况 ！！！！！！
    //     if (k == 0) return false; 

    //     for (int i = 0; i < preSum.length - 1; i++) {
    //         // j = i + 2, 保证子数组长度至少为2 ！！！！！！！！
    //         for (int j = i + 2; j < preSum.length; j++) {
    //             int sub = preSum[j] - preSum[i];
    //             if (sub % k == 0) {
    //                 return true;
    //             }
    //         }
    //     }

    //     return false;

        /* 前缀和 + hashMap (推荐) */
        if (nums.length < 2) return false; // 长度不符合最小要求

        int preSum = 0;
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        hashMap.put(0, -1);
        for (int i = 0; i < nums.length; i++) {
            preSum = preSum + nums[i];
            if (k != 0) preSum = preSum % k;
            if (hashMap.containsKey(preSum)) {
                if (i - hashMap.get(preSum) >= 2) return true;
            } else {
                hashMap.put(preSum, i);
            }
        }
        return false;
    }
}
```
**关键点1：判断该数组是否含有连续的子数组，其大小至少为 2，且总和为 k 的倍数，即总和为 n*k，其中 n 也是一个整数。**
- 前缀和 + hashMap 思想
--------------------------------------------------------------------------------
### 2.3 关键点：动态规划 思想
#### 2.3.1 最长重复子数组
[718. 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)
```java
class Solution {
    public int findLength(int[] A, int[] B) {
        if (A.length == 0 ||B.length == 0) return 0;

        // 解题思路：动态规划（注意：要和求取最长公共子序列分开）
        int[][] dp = new int[A.length + 1][B.length + 1];
        int maxRes = 0;
        for (int i = 1; i <= A.length; i++) {
            for (int j = 1; j <= B.length; j++) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    maxRes = Math.max(maxRes, dp[i][j]);
                }
            }
        }
        return maxRes;
    }
}
```
**关键点1：要和求取最长公共子序列分开**
- 对于最长公共子数组，**当 `A[i - 1] == B[j - 1]` 时，会有状态转移`dp[i][j] = dp[i - 1][j - 1] + 1;` ；否则，没有**。

#### 2.3.2 连续子数组的最大和
[剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)
```java
class Solution {
    public int maxSubArray(int[] nums) {
    	// 空间复杂度o(n)
        // if (nums == null || nums.length == 0) return 0;
        // int len = nums.length;
        // int[] dp = new int[len];
        // dp[0] = nums[0];
        // int max = dp[0];
        // for (int i = 1; i < len; i++) {
        //     if (dp[i - 1] > 0)
        //         dp[i] = dp[i - 1] + nums[i];
        //     else
        //         dp[i] = nums[i];
        //     max = Math.max(max, dp[i]);
        // }
        // return max;
		
		// 空间复杂度o(1)
        int preSum = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] >= preSum + nums[i]) {
                preSum = nums[i];
            } else {
                preSum = preSum + nums[i];
            }
            res = Math.max(res, preSum);
        }
        return res;
    }
}
```
**关键点1：两种方案**
- 空间复杂度o(1) 和 空间复杂度o(n)。

#### 2.3.2 乘积最大子数组
[713. 乘积小于K的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/)
```java
class Solution {
    public int maxProduct(int[] nums) {
        /* 动态规划 推荐 */
        // if (nums == null || nums.length == 0) return 0;

        // int res = nums[0];
        // int iMax = nums[0];
        // int iMin = nums[0];
        // for (int i = 1; i < nums.length; i++) {
        //     if (nums[i] < 0) {
        //         int temp = iMax;
        //         iMax = iMin;
        //         iMin = temp;
        //     } 
        //     iMax = Math.max(iMax * nums[i], nums[i]); // 包含当前元素的最大值
        //     iMin = Math.min(iMin * nums[i], nums[i]); // 包含当前元素的最小值
        //     res = Math.max(iMax, res); //更新整体最大值
        // }
        // return res;

        /* 动态规划 */
        if (nums == null || nums.length == 0) return 0;

        // dp[i][0]：以 nums[i] 结尾的连续子数组的最小值
        // dp[i][1]：以 nums[i] 结尾的连续子数组的最大值
        int[][] dp = new int[nums.length][2];
        dp[0][0] = nums[0];
        dp[0][1] = nums[0];
        int resMax = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > 0){
                dp[i][0] = Math.min(nums[i], dp[i - 1][0] * nums[i]);
                dp[i][1] = Math.max(nums[i], dp[i - 1][1] * nums[i]);
            } else {
                dp[i][0] = Math.min(nums[i], dp[i - 1][1] * nums[i]);
                dp[i][1] = Math.max(nums[i], dp[i - 1][0] * nums[i]);
            }
            resMax = Math.max(resMax, dp[i][1]);
        }
        return resMax;
    }
}
```
**关键点1：动态规划**

- **维护一个最大值数组`dp[i][0]`，一个最小值数组`dp[i][1]`**