## 1. 先附上LeetCode题链接

[144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

[94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

[145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

## 2. 采用递归 和 迭代两种方式进行遍历

### **2.1 前序遍历**

#### 2.1.1 递归方法

```java
/********************** 递归 ***********************/
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();

        dfs(root);
        return res;
    } 

    List<Integer> res = new ArrayList<>();
    public void dfs(TreeNode root) {
        // base case
        if (root == null) return;

        res.add(root.val); // 添加当前节点值
        dfs(root.left); // 递归左子树
        dfs(root.right); // 递归右子树
    } 
```
#### 2.1.2 迭代方法

```java
/********************** 迭代1 ***********************/
    public List<Integer> preorderTraversal(TreeNode root) {
        // base case
        if (root == null) return new ArrayList<>();

        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>(); // 自己手写一个栈
        TreeNode cur = root;
        /* 
            1. 左节点依次入栈，并将节点值加入到结果集res中
            2. 如果左节点为空的话，就弹出栈顶节点，然后判断当前节点的右节点
        */
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                res.add(cur.val); // 注意位置 ！！！！
                cur = cur.left;
            } else {
                cur = stack.pop();
                cur = cur.right;
            }
        }
        return res;
    }


    /********************** 迭代2 ***********************/
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root == null) return new ArrayList<>();

        /*
            1. 把根结点加入stack中。
            2. 开始遍历 while(!stack.isEmpty()) 执行下面的3、4步
            3. 从stack中取出栈顶的TreeNode node结点，把它加入到结果集res中
            4. 依次加入node的右孩子、左孩子（如果存在的话）
            5. 得到结果集res，返回
        */
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode cur = stack.pop();
            res.add(cur.val);
            if (cur.right != null) stack.push(cur.right);
            if (cur.left != null) stack.push(cur.left);
        }

        return res;
    } 
```
### **2.2 中序遍历**

#### 2.2.1 递归方法

```java
public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        inorder(root, res);
        return res; 
    }

    public void inorder(TreeNode root, List<Integer> res){
        //停止条件
        if (root == null) return;  

        //递归
        inorder(root.left, res);
        res.add(root.val);
        inorder(root.right, res);
    }
```

#### 2.2.2 迭代方法

```java
/************************ 迭代 ***********************/
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Stack<TreeNode> stack = new Stack<>();
        TreeNode cur = root;
        /* 
            1. 左节点依次入栈
            2. 如果左节点为空的话，就弹出栈顶节点，并将节点值加入到结果集res中，然后判断当前节点的右节点
        */
        while (cur != null || !stack.isEmpty()) {
            if (cur != null) {
                stack.push(cur);
                cur = cur.left;
            } else {
                cur = stack.pop();
                res.add(cur.val); // 注意位置 ！！！！
                cur = cur.right;
            }
        }
        return res;
    }
```

### **2.3 后序遍历**

#### 2.3.1 递归方法

```java
/************************ 递归 ***********************/
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        postOrder(root, res);
        return res; 
    }

    public void postOrder(TreeNode root, List<Integer> res){
        //停止条件
        if (root == null) return;  

        //递归
        postOrder(root.left, res);
        postOrder(root.right, res);
        res.add(root.val);
    }
```

#### 2.3.2 迭代方法

```java
/************************ 迭代 ***********************/
    public List<Integer> postorderTraversal(TreeNode root) {
        // base case
        if (root == null) return new ArrayList<>();

        Stack<TreeNode> stack = new Stack<>();
        Stack<Integer> stack2 = new Stack<>();
        List<Integer> res = new ArrayList<>();
        TreeNode cur = root;
        /*
            1. 将先序遍历转换为逆后序遍历，即 调换遍历过程中left和right的位置
            2. 将逆后序遍历转换为后序遍历，即 将逆后序遍历的结果压入stack2中，再放出来
            总结：先序（根左右） -》 逆后序（根右左） -》 后序（左右根）
        */
        while (!stack.isEmpty() || cur != null) {
            if (cur != null) {
                stack.push(cur);
                stack2.push(cur.val); // 注意位置 ！！！！
                cur = cur.right;
            } else {
                cur = stack.pop();
                cur = cur.left;
            }
        }

        while (!stack2.isEmpty()) {
            res.add(stack2.pop());
        }
        return res;
    }
```