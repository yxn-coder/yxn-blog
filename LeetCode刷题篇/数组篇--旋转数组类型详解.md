# 1、附上题目链接
[189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

[154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

-------------------------------------------------------------------------------------------------

# 2、代码关键点详解
## 2.1 关键点：旋转数组
### 2.1.1 旋转数组
[189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)
```java
class Solution {
    public void rotate(int[] nums, int k) {
        /* 翻转：时间复杂度：O(n)、空间复杂度：O(1) 推荐 */
        int n = nums.length;
        k = k % nums.length;
        reverse(nums, 0, n - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, n - 1);
    }


    public void reverse (int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start++] = nums[end];
            nums[end--] = temp;
        }
    }
}
```
 **关键点1：空间复杂度为 O(1) 的 原地 修改 流程**
1. 反转整个字符串
2. 反转区间为前 k 的子串
3. 反转区间为 k 到末尾的子串

**相关题型**

[剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

### 2.1.2 搜索旋转排序数组
[33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
 - 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1
```java
class Solution {
    public int search(int[] nums, int target) {
        if (nums.length == 1) return nums[0] == target ? 0 : -1;

        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) return mid; //成功找到，返回该值对应索引

            if (nums[left] <= nums[mid]) { // 注意：<= 而不是 < !!!!!!!!
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}
```
**关键点1：二分查找**

 - `left=0, right=arr.length-1` 
 - `middle = (right+left)/2`，若`arr[middle] == target` 结束；
 - **如果`arr[middle] >= arr[left]`，说明左半部分是有序，否则右半部分是有序**
	- **左半部分是有序时，判断target是否处于`nums[left] <= target && target < nums[mid]`之间，若是则`right = mid - 1`，若不是则`left = mid + 1`;**
    - 右半部分是有序时，同上类似。
            
### 2.1.3 寻找旋转排序数组中的最小值
[153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
 - 假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。请找出其中最小的元素
```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] < nums[right]) {
                right = mid;
            } else if (nums[mid] > nums[right]) {
                left = mid + 1;
            }
        }
        return nums[left];  /* 循环结束，left == right，最小值输出nums[left]或nums[right]均可 */  
    }
}
```
**关键点1：二分查找**
1. **中值 > 右值，最小值在右半边，收缩左边界**。 因为中值 > 右值，中值肯定不是最小值，左边界可以跨过mid `left = mid + 1;`
2. **中值 < 右值，最小值在左半边，收缩右边界**。因为中值 < 右值，中值也可能是最小值，右边界只能取到mid `right = mid;`


### 2.1.4 寻找旋转排序数组中的最小值 II
[154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)
- 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。注意数组中**可能存在重复的元素**。

```java
class Solution {
    public int findMin(int[] nums) {
        if (nums.length == 0) return -1;
        
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;

            if (nums[mid] < nums[right]) {
                right = mid;
            } else if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else if (nums[mid] == nums[right]) {
                right = right - 1;
            }
        }

        return nums[left];  /* 循环结束，left == right，最小值输出nums[left]或nums[right]均可 */  
    }
}
```
**关键点1：二分查找**
1. **中值 > 右值，最小值在右半边，收缩左边界**。 因为中值 > 右值，中值肯定不是最小值，左边界可以跨过mid `left = mid + 1;`
2. **中值 < 右值，最小值在左半边，收缩右边界**。因为中值 < 右值，中值也可能是最小值，右边界只能取到mid `right = mid;`
3.  **中值 = 右值，无法判断 最小值 在哪边**，采用 `right = right - 1` 解决此问题